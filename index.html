<!DOCTYPE html>
<html>
<head>
	<title>Risk Assesment Map</title>
</head>
<style type="text/css">
	body, #map {
		width: 100vw;
		height: 100vh;
		margin: 0;
		padding: 0;
	}

  .profile {
    width: 100px;
    height: 100px;
    text-align: center;
    border: 1px solid red;
    float:  left;
  }

  .profile .additional {
    background: green;
    display: none;
  }

  .profile .img {
    max-height: 100px;
    max-width: 100px;
  }
</style>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.4.0/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"></script>
<script src="./results.js"></script>
<body>
<div id="people-container">
  <template id="tmpl-person">
    <div class="profile">
      <img class="img" src="" />
      <div class="additional">
        <div>
          <strong>Name:</strong>
          <span class="name"></span>
        </div>
        <div>
          <strong>Bachelors:</strong>
          <span class="bachelors"></span>
        </div>
        <div>
          <strong>MSc Thesis:</strong>
          <span class="thesis_topic"></span>
        </div>
        <div>
          <strong>Country:</strong>
          <span class="country"></span>
        </div>
        <div>
          <strong>Experience:</strong>
          <span class="experience"></span>
        </div>
        <div>
          <strong>About:</strong>
          <span class="descr"></span>
        </div>
        <div>
          <strong>Email:</strong>
          <a href="" class="email"></a>
        </div>
        <a href="" class="linkedin"></a>
      </div>
    </div>
  </template>
</div>
<div id="map"></div>
<script type="text/javascript">
	var map = L.map('map').setView([0, 60], 3);

	L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
	    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
	}).addTo(map);

  // got from: https://stackoverflow.com/a/12785546
  const CSV = {
    parse: function(csv, reviver) {
        reviver = reviver || function(r, c, v) { return v; };
        var chars = csv.split(''), c = 0, cc = chars.length, start, end, table = [], row;
        while (c < cc) {
            table.push(row = []);
            while (c < cc && '\r' !== chars[c] && '\n' !== chars[c]) {
                start = end = c;
                if ('"' === chars[c]){
                    start = end = ++c;
                    while (c < cc) {
                        if ('"' === chars[c]) {
                            if ('"' !== chars[c+1]) { break; }
                            else { chars[++c] = ''; } // unescape ""
                        }
                        end = ++c;
                    }
                    if ('"' === chars[c]) { ++c; }
                    while (c < cc && '\r' !== chars[c] && '\n' !== chars[c] && ',' !== chars[c]) { ++c; }
                } else {
                    while (c < cc && '\r' !== chars[c] && '\n' !== chars[c] && ',' !== chars[c]) { end = ++c; }
                }
                row.push(reviver(table.length-1, row.length, chars.slice(start, end).join('')));
                if (',' === chars[c]) { ++c; }
            }
            if ('\r' === chars[c]) { ++c; }
            if ('\n' === chars[c]) { ++c; }
        }
        return table;
    },

    stringify: function(table, replacer) {
        replacer = replacer || function(r, c, v) { return v; };
        var csv = '', c, cc, r, rr = table.length, cell;
        for (r = 0; r < rr; ++r) {
            if (r) { csv += '\r\n'; }
            for (c = 0, cc = table[r].length; c < cc; ++c) {
                if (c) { csv += ','; }
                cell = replacer(r, c, table[r][c]);
                if (/[,\r\n"]/.test(cell)) { cell = '"' + cell.replace(/"/g, '""') + '"'; }
                csv += (cell || 0 === cell) ? cell : '';
            }
        }
        return csv;
    },

    fetch: function(url) {
  		return fetch(url)
        .then(resp => resp.text())
        .then(rawText => {
          const [cols, ...rawPeople] = this.parse(rawText);
          const data = rawPeople.map((person) => {
            return cols.reduce((dest, col, idx) => {
              return {
                ...dest,
                [col]: person[idx],
              };
            }, {});
          });

          return data;
        });
    },
  };


  const drawPeople = (people) => {
    const personTmpl = document.querySelector('#tmpl-person');
    const peopleContainer = document.querySelector('#people-container');

    people.forEach((person) => {
      const clone = document.importNode(personTmpl.content, true);

      if(person.image) {
        clone.querySelector('.img').src = `pics/${person.image}`;
      }

      clone.querySelector('.profile').dataset.id = person.id;
      clone.querySelector('.name').innerHTML = `${person.full_name}`;
      clone.querySelector('.bachelors').innerHTML = `${person.bachelors}`;
      clone.querySelector('.country').innerHTML = `${person.country}`;
      clone.querySelector('.experience').innerHTML = `${person.experience}`;
      clone.querySelector('.descr').innerHTML = `${person.descr}`;
      clone.querySelector('.thesis_topic').innerHTML = `${person.thesis_topic}`;
      clone.querySelector('.email').href = `mailto:${person.email}`;
      clone.querySelector('.email').innerHTML = `${person.email}`;
      clone.querySelector('.linkedin').src = `${person.linkein}`;
      clone.querySelector('.linkedin').innerHTML = `LinkedIn`;

      clone.querySelector('.profile').addEventListener('click', (event) => {
        const profile = event.target.closest('.profile');
        const id = profile.dataset.id;

      });

      peopleContainer.appendChild(clone);

    });
  };

	const start = async () => {
    const peoplePromise = CSV.fetch('./businesscard.csv')
      .then(people => {
        let id = 1;
        return people.map(person => ({ ...person, id: id++ }));
      });
    const countriesPromise = fetch('./countries.geo.json')
      .then(resp => resp.json());

    const [people, countries] = await Promise.all([peoplePromise, countriesPromise]);

    console.log(people, countries)

    const countriesPeople = people.reduce((dest, person) => {
      return {
        ...dest,
        [person.country_iso]: [...(dest[person.country_iso] || []), person.id],
      };
    }, {});

    for(const countryFeat of countries.features) {
      if(countriesPeople[countryFeat.id]) {
        countryFeat.properties.people = countriesPeople[countryFeat.id];
      }
    }

    L.geoJson(countries, {
      style: style,
      onEachFeature: onEachFeature,
    })
      .addTo(map);


    drawPeople(people);
	};


	start();

	function getColor(d) {
	    return d.people ? 'rgba(0, 180, 0, 0.5)' :
	                      'rgba(0,0,0,0.2)';
	}

	function getPriority(d) {
	    return d > 0.66 ? 'very high' :
	           d > 0.44  ? 'high' :
	           d > 0.22  ? 'medium' :
	           d > 0.11  ? 'low' :
	                      'very low';
	}

	function style(feature) {
	    return {
	        fillColor: getColor(feature.properties),
	        weight: 2,
	        opacity: 1,
	        color: 'white',
	        dashArray: '3',
	        fillOpacity: 0.7
	    };
	}

	var popup = L.popup();

	function onEachFeature(f, layer) {
	    //bind click
	    layer.on({
	        click: (e) => {
            popup
                .setLatLng(e.latlng)
                .setContent(`<b>Usage:</b> ${f.properties.usage}
                	<br><b>Built year:</b> ${f.properties.built_year}
                	<br><b>Priority:</b> ${getPriority(f.properties.risk_weighted_normalized)}`)
                .openOn(map);
	        }
	    });
	}
	// function onMapClick(e) {
	// 	console.log(arguments)
	// }

</script>
</body>
</html>